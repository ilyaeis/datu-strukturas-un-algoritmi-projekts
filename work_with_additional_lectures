import json
from collections import defaultdict
from datetime import datetime
import pandas as pd

def convert_json_to_excel(start_date, end_date):
    # start_date = 12
    # end_dae = 25
    def duration_in_minutes(time_slot):
        try:
            start_str, end_str = time_slot.split(" - ")
            start = datetime.strptime(start_str, "%H:%M")
            end = datetime.strptime(end_str, "%H:%M")
            delta = end - start
            return delta.total_seconds() / 60
        except Exception as e:
            print(f"Warning: could not parse time slot '{time_slot}': {e}")
            return None

    allowed_start_times = {"08:15", "10:15", "12:30", "14:30", "16:30"}

    # Read JSON
    with open("all_possible_additional_lectures.json", "r", encoding="utf-8") as f:
        data = json.load(f)

    # Build nested dictionary WITHOUT date level
    combined_data = {
        "A": defaultdict(lambda: defaultdict(lambda: defaultdict(lambda: {"group_count": 0, "group": None}))),
        "B": defaultdict(lambda: defaultdict(lambda: defaultdict(lambda: {"group_count": 0, "group": None}))),
    }

    for date_str, schedule in data.items():
        date_obj = datetime.strptime(date_str, "%Y-%m-%d")

        # Skip weekends
        if date_obj.weekday() >= 5:
            continue

        # Only days 12 to 25 inclusive
        if not (12 <= date_obj.day <= 25):
            continue

        # Calculate week type A or B (based on offset from 12th)
        reference_date = date_obj.replace(day=12)
        if date_obj < reference_date:
            if date_obj.month == 1:
                reference_date = reference_date.replace(year=date_obj.year - 1, month=12)
            else:
                reference_date = reference_date.replace(month=date_obj.month - 1)

        days_diff = (date_obj - reference_date).days
        week_number = days_diff // 7
        week_type = 'A' if week_number % 2 == 0 else 'B'

        weekday = date_obj.weekday()  # 0 = Monday, 1 = Tuesday, ..., 4 = Friday

        for time_slot, lectures in schedule.items():
            try:
                start_time = time_slot.split(" - ")[0]
            except Exception as e:
                print(f"Warning: skipping invalid time slot '{time_slot}': {e}")
                continue

            if start_time not in allowed_start_times:
                continue

            duration = duration_in_minutes(time_slot)
            if duration is None or duration > 120:
                continue

            for entry in lectures:
                try:
                    group_info, lecture_title = entry.split(" ||| ")
                except ValueError:
                    continue

                lecture_title = lecture_title.strip()
                group_info = group_info.strip()

                lec = combined_data[week_type][weekday][time_slot][lecture_title]
                lec["group_count"] += 1
                if lec["group"] is None:
                    lec["group"] = group_info

    # Prepare output rows (without date)
    rows = []
    weekday_map = {0: "Monday", 1: "Tuesday", 2: "Wednesday", 3: "Thursday", 4: "Friday"}

    for week_type in ["A", "B"]:
        for weekday in range(5):
            weekday_name = weekday_map[weekday]
            for time_slot in sorted(combined_data[week_type][weekday].keys()):
                lectures = combined_data[week_type][weekday][time_slot]
                for lecture_title in sorted(lectures.keys()):
                    lec = lectures[lecture_title]
                    rows.append({
                        "Week Type": week_type,
                        "Weekday": weekday_name,
                        "Time Slot": time_slot,
                        "Lecture Title": lecture_title,
                        "Group Count": lec["group_count"],
                        "Example Group": lec["group"]
                    })

    # Create DataFrame and sort
    df = pd.DataFrame(rows)

    # Sort weekdays properly
    weekday_order = {"Monday": 0, "Tuesday": 1, "Wednesday": 2, "Thursday": 3, "Friday": 4}
    df["WeekdayNum"] = df["Weekday"].map(weekday_order)
    df.sort_values(by=["Week Type", "WeekdayNum", "Time Slot", "Lecture Title"], inplace=True)
    df.drop(columns=["WeekdayNum"], inplace=True)

    # Export to Excel
    df.to_excel("result.xlsx", index=False)

    print("Output written to 'result.xlsx'")
